name: New Test RDP

on:
  workflow_dispatch:

jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: 3600
    env:
      # Optional: stable password across re-runs (recommended)
      RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
      # Required: real Tailscale AUTH key (tskey-auth-... or tskey-ephemeral-...)
      TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}

    steps:
      - name: Configure Core RDP Settings (idempotent)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          # Enable RDP
          $tsKey = 'HKLM:\System\CurrentControlSet\Control\Terminal Server'
          $cur = Get-ItemProperty -Path $tsKey -Name fDenyTSConnections -ErrorAction SilentlyContinue
          if ($null -eq $cur -or $cur.fDenyTSConnections -ne 0) {
            Set-ItemProperty -Path $tsKey -Name fDenyTSConnections -Value 0 -Force
          }

          # (Optional) relax NLA/security for compatibility (set to 1/1 if you want NLA)
          $rdpKey = 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp'
          foreach ($name in 'UserAuthentication','SecurityLayer') {
            if (-not (Get-ItemProperty -Path $rdpKey -Name $name -ErrorAction SilentlyContinue)) {
              New-ItemProperty -Path $rdpKey -Name $name -PropertyType DWord -Value 0 -Force | Out-Null
            } else {
              Set-ItemProperty -Path $rdpKey -Name $name -Value 0 -Force
            }
          }

          # Ensure single firewall rule for 3389
          $ruleName = 'RDP-Tailscale'
          $rule = Get-NetFirewallRule -DisplayName $ruleName -ErrorAction SilentlyContinue
          if ($null -eq $rule) {
            New-NetFirewallRule -DisplayName $ruleName -Direction Inbound -Action Allow -Protocol TCP -LocalPort 3389 | Out-Null
          } else {
            Set-NetFirewallRule -DisplayName $ruleName -Enabled True -Action Allow | Out-Null
          }

          # Make sure service is auto and restarted
          Set-Service -Name TermService -StartupType Automatic
          Restart-Service -Name TermService -Force -ErrorAction SilentlyContinue

      - name: Create/Ensure RDP User (idempotent)
        id: create_user
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $userName = 'RDP'
          $existing = Get-LocalUser -Name $userName -ErrorAction SilentlyContinue

          function New-RandomPassword {
            Add-Type -AssemblyName System.Security
            $charSet = @{
              Upper   = [char[]](65..90)
              Lower   = [char[]](97..122)
              Number  = [char[]](48..57)
              Special = ([char[]](33..47) + [char[]](58..64) + [char[]](91..96) + [char[]](123..126))
            }
            $raw = @()
            $raw += $charSet.Upper   | Get-Random -Count 4
            $raw += $charSet.Lower   | Get-Random -Count 4
            $raw += $charSet.Number  | Get-Random -Count 4
            $raw += $charSet.Special | Get-Random -Count 4
            -join ($raw | Sort-Object { Get-Random })
          }

          $passwordToUse = $env:RDP_PASSWORD
          $createdNew = $false

          if ($null -eq $existing) {
            if (-not $passwordToUse) { $passwordToUse = New-RandomPassword }
            $secure = ConvertTo-SecureString $passwordToUse -AsPlainText -Force
            New-LocalUser -Name $userName -Password $secure -AccountNeverExpires | Out-Null
            Write-Host "Created local user '$userName'."
            $createdNew = $true
          } else {
            Write-Host "User '$userName' already exists. Skipping creation."
            # If you *want* to force-reset on reruns when RDP_PASSWORD is provided, uncomment next lines:
            # if ($passwordToUse) {
            #   try {
            #     $secure = ConvertTo-SecureString $passwordToUse -AsPlainText -Force
            #     Set-LocalUser -Name $userName -Password $secure
            #     Write-Host "Synchronized user password from secret."
            #   } catch {
            #     Write-Warning "Could not reset password; proceeding with existing password."
            #   }
            # }
          }

          # Ensure group memberships (idempotent)
          foreach ($grp in 'Administrators','Remote Desktop Users') {
            $members = Get-LocalGroupMember -Group $grp -ErrorAction SilentlyContinue
            if ($null -eq ($members | Where-Object { $_.Name -like "*\$userName" })) {
              Add-LocalGroupMember -Group $grp -Member $userName -ErrorAction SilentlyContinue
            }
          }

          # Only expose password when newly created (or if you re-enable forced reset above)
          if ($createdNew -and $passwordToUse) {
            "RDP_CREDS=User: $userName | Password: $passwordToUse" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          }

          # Output a flag for later steps
          "created=$createdNew" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Install/Ensure Tailscale (idempotent)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $desiredVersion = '1.82.0'
          $tsExe = Join-Path $env:ProgramFiles 'Tailscale\tailscale.exe'
          $needInstall = $true

          if (Test-Path $tsExe) {
            try {
              $verLine = & $tsExe version 2>$null
              if ($verLine -match [regex]::Escape($desiredVersion)) { $needInstall = $false }
            } catch { $needInstall = $true }
          }

          if ($needInstall) {
            $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-$desiredVersion-amd64.msi"
            $installerPath = "$env:TEMP\tailscale.msi"
            Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath
            Start-Process msiexec.exe -ArgumentList "/i","`"$installerPath`"","/quiet","/norestart" -Wait
            Remove-Item $installerPath -Force
            Write-Host "Installed/updated Tailscale $desiredVersion."
          } else {
            Write-Host "Tailscale $desiredVersion already installed."
          }

      - name: Establish/Reuse Tailscale Connection
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $ts = Join-Path $env:ProgramFiles 'Tailscale\tailscale.exe'

          if (-not $env:TAILSCALE_AUTH_KEY) { throw "TAILSCALE_AUTH_KEY secret is required." }
          if ($env:TAILSCALE_AUTH_KEY -notmatch '^tskey-(auth|ephemeral)-') {
            throw "TAILSCALE_AUTH_KEY must start with tskey-auth- or tskey-ephemeral-."
          }

          # Try to fetch existing IP first (idempotent)
          $tsIP = & $ts ip -4 2>$null
          if (-not $tsIP) {
            & $ts up --authkey="$env:TAILSCALE_AUTH_KEY" --hostname="gh-runner-$env:GITHUB_RUN_ID" --force-reauth
            Start-Sleep -Seconds 3
            $tsIP = & $ts ip -4
          }

          $retries = 0
          while (-not $tsIP -and $retries -lt 10) {
            Start-Sleep -Seconds 5
            $tsIP = & $ts ip -4
            $retries++
          }

          if (-not $tsIP) {
            $status = & $ts status 2>$null
            throw "Tailscale IP not assigned. Current status:`n$status"
          }

          "TAILSCALE_IP=$tsIP" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Tailscale IP: $tsIP"

      - name: Verify RDP Accessibility
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Testing TCP 3389 on $env:TAILSCALE_IP ..."
          $ok = Test-NetConnection -ComputerName $env:TAILSCALE_IP -Port 3389 -InformationLevel Quiet
          if (-not $ok) {
            Write-Warning "Self-connection via Tailscale failed; checking local listener on 3389..."
            $listening = Get-NetTCPConnection -LocalPort 3389 -State Listen -ErrorAction SilentlyContinue
            if (-not $listening) { throw "RDP is not listening on port 3389" }
          }
          Write-Host "RDP appears reachable/listening."

      - name: Maintain Connection (until cancelled)
        shell: pwsh
        run: |
          Write-Host "`n=== RDP ACCESS ==="
          Write-Host "Address: $env:TAILSCALE_IP"
          Write-Host "Username: RDP"
          # Only show password when the user was just created
          if ("${{ steps.create_user.outputs.created }}" -eq "True") {
            Write-Host "Password: (see RDP_CREDS in env)"
            Write-Host $env:RDP_CREDS
          } else {
            Write-Host "Password: (unchanged; not displayed)"
          }
          Write-Host "==================`n"
          while ($true) {
            Write-Host "[$(Get-Date)] RDP Active - cancel the workflow to terminate"
            Start-Sleep -Seconds 300
          }
